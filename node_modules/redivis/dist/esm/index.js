import Papa from 'papaparse';

let authToken;
let fetch$1;
let crypto;
let popupWindowReference;
let currentGetAuthTokenPromise;

async function authorize({ apiToken }) {
	if (apiToken) {
		return setCachedAuthToken({ access_token: apiToken, expires_at: Date.now() + 1e10 });
	}
	await getAuthToken({ apiToken, forceReauthorization: true });
}

async function getAuthToken({ forceReauthorization = false }) {
	if (currentGetAuthTokenPromise) {
		if (forceReauthorization) {
			await currentGetAuthTokenPromise;
		} else {
			return currentGetAuthTokenPromise;
		}
	}

	currentGetAuthTokenPromise = (async function () {
		if (forceReauthorization) {
			authToken = null;
		} else if (!authToken) {
			authToken = await getCachedAuthToken();
		}
		if (!crypto) {
			await importCrypto();
		}
		if (!fetch$1) {
			await importFetch();
		}

		if (authToken && new Date(authToken.expires_at * 1000) > Date.now()) {
			return authToken?.access_token;
		}
		if (typeof process !== 'undefined' && process?.env?.REDIVIS_API_TOKEN) {
			return process.env.REDIVIS_API_TOKEN;
		}
		if (typeof window === 'undefined') {
			authToken = await oAuthNode();
		} else {
			authToken = await oAuthBrowser();
		}
		await setCachedAuthToken(authToken);
		return authToken?.access_token;
	})();
	return currentGetAuthTokenPromise;
}

async function getCachedAuthToken() {
	try {
		if (typeof window === 'undefined') {
			const { default: keytar } = await import('keytar');
			const res = await keytar.getPassword('redivis-node', 'user@redivis.com');
			if (res) {
				return JSON.parse(res);
			}
			return null;
		} else {
			const res = sessionStorage.getItem('redivis_oauth_token');
			if (res) {
				return JSON.parse(res);
			}
			return null;
		}
	} catch (e) {
		// ignore
	}
}

async function setCachedAuthToken(token) {
	try {
		if (typeof window === 'undefined') {
			const { default: keytar } = await import('keytar');
			return keytar.setPassword('redivis-node', 'user@redivis.com', JSON.stringify(token));
		} else {
			sessionStorage.setItem('redivis_oauth_token', JSON.stringify(token));
		}
	} catch (e) {
		//ignore
	}
}

async function oAuthNode() {
	const readline = await import('readline');

	const rl = readline.createInterface({
		input: process.stdin,
		output: process.stdout,
	});

	const scope = 'data.data';
	const state = generateRandomString();
	const redirectUri = 'urn:ietf:wg:oauth:2.0:oob';
	const { challenge, verifier } = await getPKCE();

	const baseUrl = process.env.REDIVIS_API_ENDPOINT
		? process.env.REDIVIS_API_ENDPOINT.match(/(https:\/\/.*?)\//)[1]
		: `https://redivis.com`;

	// TODO: open browser + local server authentication flow
	const url = `${baseUrl}/oauth/authorize?scope=${scope}&redirect_uri=${redirectUri}&response_type=code&state=${state}&code_challenge=${challenge}&code_challenge_method=S256`;

	console.log(
		`You must be logged in to perform this action. Please navigate to the following URL to get an authorization code.\n`,
	);
	console.log(url);

	let authCode;
	function validateAuthorizationCode() {
		return new Promise((resolve, reject) => {
			rl.question('\nEnter the authorization code:', async function (code) {
				try {
					authCode = code;

					const res = await fetch$1(`${baseUrl}/oauth/token`, {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json',
						},
						body: JSON.stringify({
							grant_type: 'authorization_code',
							code: authCode,
							redirect_uri: decodeURIComponent(redirectUri),
							code_verifier: verifier,
						}),
					});

					// TODO: should we validate state here? Somehow need to include it in the code... should look up if necessary
					const parsedResponse = await res.json();
					if (res.status >= 400) {
						throw new Error(parsedResponse.error);
					}
					rl.close();
					resolve(parsedResponse);
				} catch (e) {
					reject(e);
				}
			});
		});
	}

	while (true) {
		try {
			return await validateAuthorizationCode();
		} catch (e) {
			console.error(`Invalid authorization code: ${e.message}`);
		}
	}
}

async function oAuthBrowser() {
	const scope = 'data.data';
	const redirectUri = encodeURIComponent('urn:ietf:wg:oauth:2.0:oob:auto');
	const state = generateRandomString();
	const { challenge, verifier } = await getPKCE();
	const url = `https://redivis.com/oauth/authorize?&scope=${scope}&redirect_uri=${redirectUri}&response_type=code&state=${state}&code_challenge=${challenge}&code_challenge_method=S256`;
	const popupWindowSettings = 'toolbar=no,menubar=no,width=600,height=600,left=100,top=100';

	return new Promise((resolve, reject) => {
		if (!popupWindowReference || popupWindowReference?.closed) {
			popupWindowReference = window.open(url, 'Authorize Redivis', popupWindowSettings);
		}
		if (
			!popupWindowReference ||
			popupWindowReference.closed ||
			typeof popupWindowReference.closed === 'undefined'
		) {
			return reject(
				new Error(
					`The Redivis authentication window was blocked by the browser. Please enable popups for this page and try again.`,
				),
			);
		}
		popupWindowReference.focus();

		const popupClosedInterval = setInterval(function () {
			if (!popupWindowReference || popupWindowReference.closed) {
				clearInterval(popupClosedInterval);
				window.removeEventListener('message', onMessageEventHandler);
				return reject(new Error(`The Redivis authentication window was prematurely closed. Please try again.`));
			}
		}, 500);

		// add the listener for receiving a message from the popup
		async function onMessageEventHandler(event) {
			try {
				window.removeEventListener('message', onMessageEventHandler);

				clearInterval(popupClosedInterval);

				if (!url.startsWith(event.origin)) {
					throw new Error(`Invalid origin`);
				}
				const { code, state: finalState } = JSON.parse(event.data);
				if (state !== finalState) {
					throw new Error(`An error occurred during login. Inconsistent state.`);
				}
				const res = await fetch$1(`https://redivis.com/oauth/token`, {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
					},
					body: JSON.stringify({
						grant_type: 'authorization_code',
						code,
						redirect_uri: decodeURIComponent(redirectUri),
						code_verifier: verifier,
					}),
				});

				const parsedResponse = await res.json();
				if (res.status >= 400) {
					throw new Error(parsedResponse.error);
				}
				resolve(parsedResponse);
			} catch (e) {
				reject(e);
			}
		}

		window.addEventListener('message', onMessageEventHandler);
	});
}

async function getPKCE() {
	const verifier = generateRandomString();
	const challenge = await pkceChallengeFromVerifier(verifier);
	return { verifier, challenge };
}

async function importCrypto() {
	if (!crypto) {
		if (typeof window === 'undefined') {
			const { webcrypto } = await import('crypto');
			crypto = webcrypto;
		} else {
			crypto = window.crypto;
		}
	}
}

async function importFetch() {
	if (!fetch$1) {
		if (typeof window === 'undefined') {
			const { default: nodeFetch } = await import('node-fetch');
			fetch$1 = nodeFetch;
		} else {
			fetch$1 = window.fetch;
		}
	}
}

function generateRandomString() {
	const array = new Uint32Array(56 / 2);
	crypto.getRandomValues(array);
	return Array.from(array, dec2hex).join('');
}

function dec2hex(dec) {
	return ('0' + dec.toString(16)).substr(-2);
}

function sha256(plain) {
	// returns promise ArrayBuffer
	const encoder = new TextEncoder();
	const data = encoder.encode(plain);
	return crypto.subtle.digest('SHA-256', data);
}

function base64urlencode(a) {
	// Convert the ArrayBuffer to string using Uint8 array.
	// btoa takes chars from 0-255 and base64 encodes.
	// Then convert the base64 encoded to base64url encoded.
	// (replace + with -, replace / with _, trim trailing =)
	let base64String;
	if (typeof window === 'undefined') {
		base64String = Buffer.from(new Uint8Array(a)).toString('base64');
	} else {
		base64String = btoa(String.fromCharCode.apply(null, new Uint8Array(a)));
	}
	return base64String.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

async function pkceChallengeFromVerifier(v) {
	const hashed = await sha256(v);
	return base64urlencode(hashed);
}

let fetch;
if (typeof window !== 'undefined') {
	fetch = window.fetch;
}

if (typeof process !== 'undefined') {
	if (process.env?.REDIVIS_API_ENDPOINT && process.env.REDIVIS_API_ENDPOINT.startsWith('https://localhost')) {
		process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = 0;
	}
}

function getApiEndpoint() {
	if (typeof process !== 'undefined') {
		return process.env?.REDIVIS_API_ENDPOINT || 'https://redivis.com/api/v1';
	} else {
		return 'https://redivis.com/api/v1';
	}
}

async function makeRequest({ method, path, query, payload, forceReauthorization = false }) {
	let url = `${getApiEndpoint()}${path}`;
	const authToken = await getAuthToken({ forceReauthorization });
	const headers = { Authorization: `Bearer ${authToken}` };

	if (query) {
		url += `?${Object.entries(query)
			.map(([key, value]) => `${key}=${value}`)
			.join('&')}`;
	}

	payload = JSON.stringify(payload);
	if (!fetch) {
		const { default: nodeFetch } = await import('node-fetch');
		fetch = nodeFetch;
	}
	const response = await fetch(url, { method, headers, body: payload });
	let parsedResponse;

	if (response.headers.get('content-type')?.startsWith?.('application/json')) {
		parsedResponse = await response.json();
	} else {
		parsedResponse = await response.text();
	}
	if (response.status >= 400) {
		if (response.status === 401) {
			return makeRequest({ method, path, query, payload, forceReauthorization: true });
		}
		const err = new Error(parsedResponse.error?.message || parsedResponse);
		if (parsedResponse.error) {
			for (const [key, value] of Object.entries(parsedResponse.error)) {
				err[key] = value;
			}
		}
		err.status = response.status;
		throw err;
	}
	return parsedResponse;
}

async function makePaginatedRequest({ path, pageSize = 100, query = {}, maxResults }) {
	const results = [];
	let page = 0;
	let nextPageToken;

	while (true) {
		if (maxResults && results.length >= maxResults) break;

		if (nextPageToken) {
			query.pageToken = nextPageToken;
		}

		const response = await makeRequest({
			method: 'GET',
			path,
			query: {
				...query,
				maxResults:
					maxResults === undefined || (page + 1) * pageSize < maxResults
						? pageSize
						: maxResults - page * pageSize,
			},
		});
		page++;
		results.push(...response.results);
		nextPageToken = response.nextPageToken;
		if (!nextPageToken) {
			break;
		}
	}
	return results;
}

async function makeRowsRequest({ uri, maxResults, query = {} }) {
	// TODO: we should leverage streams in nodejs environments
	const res = await makeRequest({
		method: 'GET',
		path: `${uri}/rows`,
		query: {
			...query,
			maxResults,
		},
	});
	return res;
}

// TODO: add statistics, getRows

class Variable {
	constructor(argName, options = {}) {
		if (typeof argName === 'object') {
			options = argName;
			argName = undefined;
		}
		const { name = argName, label, description, valueLabels, type, table, query, properties = {} } = options;
		this.name = name;
		this.type = type;
		this.table = table;
		this.query = query;
		this.properties = { name, type, label, description, valueLabels, ...properties };
		this.uri = `${(this.table || this.query).uri}/variables/${this.name}`;
	}
	getProperty(prop) {
		return this.properties?.[prop];
	}
	toString() {
		return JSON.stringify(this.properties, null, 2);
	}

	async exists() {
		try {
			await makeRequest({ method: 'GET', path: this.uri });
		} catch (e) {
			if (e.status !== 404) {
				throw e;
			}
			return false;
		}
		return true;
	}

	async get() {
		this.properties = await makeRequest({ method: 'GET', path: this.uri });
		this.uri = this.properties.uri;
		return this;
	}
}

// TODO: handle periods in name (properly escape) â€” and for all other entities
class Table {
	constructor(argName, options = {}) {
		if (typeof argName === 'object') {
			options = argName;
			argName = undefined;
		}
		const { name = argName, sample = false, dataset, project, properties } = options;
		const parent = dataset || project;
		const owner = parent.organization || parent.user;
		const sampleString = sample ? ':sample' : '';
		const versionString = dataset ? `:${dataset.version}` : '';
		this.hasPopulatedProperties = false;
		this.name = name;
		this.dataset = dataset;
		this.project = project;
		this.identifier = `${owner.name}.${parent.name}:${versionString}.${this.name}${sampleString}`;
		this.uri = `/tables/${encodeURIComponent(this.identifier)}`;
		this.properties = { name, identifier: this.identifier, uri: this.uri, dataset, project, ...properties };
	}

	// TODO: validate properties usage
	getProperty(prop) {
		return this.properties?.[prop];
	}

	toString() {
		return JSON.stringify(this.properties, null, 2);
	}

	variable(name) {
		return new Variable(name, { table: this });
	}

	async exists() {
		try {
			await makeRequest({ method: 'GET', path: this.uri });
		} catch (e) {
			if (e.status !== 404) {
				throw e;
			}
			return false;
		}
		return true;
	}

	async get() {
		this.properties = await makeRequest({ method: 'GET', path: this.uri });
		this.uri = this.properties.uri;
		this.hasPopulatedProperties = true;
		return this;
	}

	async listVariables({ maxResults } = {}) {
		let variables = await makePaginatedRequest({ path: `${this.uri}/variables`, pageSize: 1000, maxResults });
		variables = variables.map((variable) => new Variable({ ...variable, table: this }));
		if (maxResults === undefined || variables.length < maxResults) {
			this.variables = variables;
		}
		return variables;
	}

	async listRows(argMaxResults, options = {}) {
		if (typeof argMaxResults === 'object') {
			options = argMaxResults;
			argMaxResults = undefined;
		}
		let { maxResults = argMaxResults, variables } = options;

		if (!this.variables) {
			this.variables = await this.listVariables({ maxResults: 10000 });
		}
		if (!this.hasPopulatedProperties) {
			await this.get();
		}
		maxResults = maxResults === undefined ? this.properties.numRows : Math.min(maxResults, this.properties.numRows);

		let selectedVariables = this.variables;
		if (variables?.length) {
			selectedVariables = variables.map((name) => {
				const variable = this.variables.find(
					({ name: variableName }) => variableName.toLowerCase() === name.toLowerCase(),
				);
				if (!variable) {
					throw new Error(`The variable ${name} was not found in this table`);
				}
				return { name, type: variable.type };
			});
		}

		const res = await makeRowsRequest({
			uri: this.uri,
			maxResults,
			query: {
				selectedVariables: selectedVariables.map((variable) => variable.name).join(','),
				format: 'csv',
			},
		});

		const { data: rows } = Papa.parse(res);

		return rows.map((row) => {
			const rowObject = {};
			for (let i = 0; i < row.length; i++) {
				if (row[i] === null) {
					rowObject[selectedVariables[i].name] = row[i];
				} else {
					switch (selectedVariables[i].type) {
						case 'integer':
							rowObject[selectedVariables[i].name] = parseInt(row[i]);
							break;
						case 'float':
							rowObject[selectedVariables[i].name] = parseFloat(row[i]);
							break;
						case 'date':
							rowObject[selectedVariables[i].name] = new Date(`${row[i]}T00:00:00Z`);
							break;
						case 'dateTime':
							rowObject[selectedVariables[i].name] = new Date(`${row[i]}Z`);
							break;
						default:
							rowObject[selectedVariables[i].name] = row[i];
					}
				}
			}
			return rowObject;
		});
	}
}
// TODO
// class Table:

//     def create(self, *, description=None, upload_merge_strategy="append"):
//         response = make_request(
//             method="POST",
//             path=f"{self.dataset.uri}/tables",
//             payload={
//                 "name": self.name,
//                 "description": description,
//                 "uploadMergeStrategy": upload_merge_strategy,
//             },
//         )
//         self.properties = response
//         self.uri = self.properties["uri"]
//         return self

//     def update(self, *, name=None, description=None, upload_merge_strategy=None):
//         payload = {}
//         if name:
//             payload["name"] = name
//         if upload_merge_strategy:
//             payload["mergeStrategy"] = upload_merge_strategy
//         if description is not None:
//             payload["description"] = description

//         response = make_request(
//             method="PATCH",
//             path=f"{self.uri}",
//             payload=payload,
//         )
//         self.properties = response
//         return

//     def delete(self):
//         make_request(
//             method="DELETE",
//             path=self.uri,
//         )
//         return

//     def upload(self, *, name, data, type, remove_on_fail=True):
//         response = make_request(
//             method="POST",
//             path=f"{self.uri}/uploads",
//             payload={"name": name, "type": type},
//         )
//         upload = Upload(uri=response["uri"])
//         try:
//             upload.upload_file(data)
//             while True:
//                 time.sleep(2)
//                 upload.get()
//                 if upload["status"] == "completed":
//                     break
//                 elif upload["status"] == "failed":
//                     raise Exception(upload["errorMessage"])
//                 else:
//                     logging.debug("Upload is still in progress...")
//         except Exception as e:
//             if remove_on_fail:
//                 print("An error occurred. Deleting upload.")
//                 upload.delete()
//             raise e

//         return upload

//     def list_uploads(self, *, max_results=None):
//         uploads = make_paginated_request(
//             path=f"{self.uri}/uploads", max_results=max_results
//         )
//         return [Upload(upload) for upload in uploads]

class Query {
	constructor(argsQuery, options = {}) {
		this.isFetching = true;
		if (typeof argsQuery === 'object') {
			options = argsQuery;
			argsQuery = undefined;
		}
		const { query = argsQuery, defaultProject, defaultDataset } = options;
		const payload = {
			query,
		};
		if (defaultProject) {
			payload.defaultProject = defaultProject.identifier;
		} else if (defaultDataset) {
			payload.defaultDataset = defaultDataset.identifier;
		}

		// TODO: only make the request when this.get is called
		makeRequest({ method: 'POST', path: '/queries', payload })
			.then((res) => {
				this.isFetching = false;
				this.properties = res;
				this.uri = `/queries/${this.properties.id}`;
			})
			.catch((e) => {
				this.error = e;
				this.isFetching = false;
			});
	}

	getProperty(prop) {
		return this.properties?.[prop];
	}

	toString() {
		return JSON.stringify(this.properties, null, 2);
	}

	async get() {
		this.properties = await makeRequest({ method: 'GET', path: this.uri });
		return this;
	}

	async listVariables() {
		await this.#waitForFinish();
		return this.properties.outputSchema.map((variable) => new Variable({ ...variable, query: this }));
	}

	async listRows(maxResults) {
		await this.#waitForFinish();
		maxResults =
			maxResults === undefined
				? this.properties.outputNumRows
				: Math.max(maxResults, this.properties.outputNumRows);
		const res = await makeRowsRequest({ uri: this.uri, maxResults, query: { format: 'csv' } });
		const { data: rows } = Papa.parse(res);
		const variables = await this.listVariables();
		return rows.map((row) => {
			const rowObject = {};
			for (let i = 0; i < row.length; i++) {
				if (row[i] === null) {
					rowObject[variables[i].name] = row[i];
				} else {
					switch (variables[i].type) {
						case 'integer':
							rowObject[variables[i].name] = parseInt(row[i]);
							break;
						case 'float':
							rowObject[variables[i].name] = parseFloat(row[i]);
							break;
						case 'date':
							rowObject[variables[i].name] = new Date(`${row[i]}T00:00:00Z`);
							break;
						case 'dateTime':
							rowObject[variables[i].name] = new Date(`${row[i]}Z`);
							break;
						default:
							rowObject[variables[i].name] = row[i];
					}
				}
			}
			return rowObject;
		});
	}

	async #waitForFinish() {
		while (true) {
			if (this.isFetching) {
				await new Promise((resolve) => setTimeout(resolve, 2000));
				continue;
			} else if (this.error) {
				throw new Error(this.error);
			} else if (this.properties.status === 'completed') {
				break;
			} else if (this.properties.status === 'failed') {
				throw new Error(`Query job failed with message: ${this.properties.errorMessage}`);
			} else if (this.properties.status === 'cancelled') {
				throw new Error(`Query job was cancelled`);
			} else {
				await new Promise((resolve) => setTimeout(resolve, 2000));
				await this.get();
			}
		}
	}
}

// TODO: listAccess
// TODO: finalize sample, versions

class Dataset {
	constructor(argName, options = {}) {
		if (typeof argName === 'object') {
			options = argName;
			argName = undefined;
		}
		const { name = argName, version = 'current', user, organization, properties = {} } = options;

		this.name = name;
		this.version = version;
		this.user = user;
		this.organization = organization;
		this.identifier = `${(this.organization || this.user).name}.${this.name}:${this.version}`;
		this.uri = `/datasets/${encodeURIComponent(this.identifier)}`;
		this.properties = properties;
	}

	toString() {
		return JSON.stringify(this.properties, null, 2);
	}

	getProperty(property) {
		return this.properties?.[property];
	}

	table(name, options = {}) {
		return new Table({ name, ...options, dataset: this });
	}

	query(query, options = {}) {
		return new Query({ query, ...options, defaultDataset: this });
	}

	async exists() {
		try {
			await makeRequest({ method: 'GET', path: this.uri });
		} catch (e) {
			if (e.status !== 404) {
				throw e;
			}
			return false;
		}
		return true;
	}

	async get() {
		this.properties = await makeRequest({ method: 'GET', path: this.uri });
		this.uri = this.properties.uri;
		return this;
	}

	async create({ publicAccessLevel = 'none', description } = {}) {
		let path;
		if (this.organization) {
			path = `/organizations/${this.organization.name}/datasets`;
		} else {
			path = `/users/${this.user.name}/datasets`;
		}

		this.properties = await makeRequest({
			method: 'POST',
			path,
			payload: {
				name: this.name,
				description,
				publicAccessLevel,
			},
		});
		this.uri = this.properties.uri;
		return this;
	}

	async update({ name, publicAccessLevel, description } = {}) {
		const payload = {};

		if (name) payload.name = name;
		if (publicAccessLevel) payload.publicAccessLevel = publicAccessLevel;
		if (description) payload.description = description;

		this.properties = await makeRequest({
			method: 'POST',
			path: this.uri,
			payload,
		});
		return this;
	}

	async delete() {
		await makeRequest({ method: 'DELETE', path: this.uri });
	}

	async createNextVersion({ ignoreIfExists = false } = {}) {
		if (!this.properties?.nextVersion) {
			await this.get();
		}
		if (!this.properties.nextVersion) {
			await makeRequest({ method: 'POST', path: `${this.uri}/versions` });
		} else if (!ignoreIfExists) {
			throw new Error(
				`Next version already exists at ${this.properties.nextVersion.datasetUri}. To avoid this error, set option ignoreIfExists to true`,
			);
		}
		return new Dataset(this.name, {
			user: this.user,
			organization: this.organization,
		}).get();
	}

	async release() {
		await makeRequest({
			method: 'POST',
			path: `${this.uri}/versions/next/release`,
		});
		return new Dataset(this.name, {
			user: this.user,
			organization: this.organization,
			version: 'current',
		}).get();
	}

	async listTables({ maxResults } = {}) {
		const tables = await makePaginatedRequest({
			path: `${this.uri}/tables`,
			pageSize: 100,
			maxResults,
		});
		return tables.map((table) => new Table(table.name, { dataset: this, properties: table }));
	}
}

// TODO: listDatasets
// TODO: listMembers

class Organization {
	constructor(name) {
		this.name = name;
	}

	dataset(name, options = {}) {
		return new Dataset({ name, ...options, organization: this });
	}
}

class Project {
	constructor(argName, options = {}) {
		if (typeof argName === 'object') {
			options = argName;
			argName = undefined;
		}
		const { name = argName, user, properties } = options;
		this.user = user;
		this.name = name;
		this.identifier = `${user.name}.${name}`;
		this.uri = `/projects/${encodeURIComponent(this.identifier)}`;
		this.properties = properties;
	}

	getProperty() {
		return this.properties?.[property];
	}

	query(query, options = {}) {
		return new Query({ query, ...options, defaultProject: this });
	}

	table(name, options = {}) {
		return new Table({ name, ...options, project: this });
	}

	async listTables({ maxResults, includeDatasetTables } = {}) {
		const tables = await makePaginatedRequest({
			method: 'GET',
			pageSize: 100,
			path: `${this.uri}/tables`,
			maxResults,
			query: { includeDatasetTables },
		});

		return tables.map((table) => new Table(table.name, { project: this, properties: table }));
	}
}

// TODO: list datasets
// TODO: list projects

class User {
	constructor(name) {
		this.name = name;
	}

	dataset(name, options = {}) {
		return new Dataset({ name, ...options, user: this });
	}
	project(name, options = {}) {
		return new Project({ name, ...options, user: this });
	}
}

function organization(name) {
	return new Organization(name);
}

function user(name) {
	return new User(name);
}

function query(name) {
	return new Query(name);
}

export { authorize, organization, query, user };
