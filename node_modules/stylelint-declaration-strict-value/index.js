'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.messages = exports.ruleName = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _stylelint = require('stylelint');

var _stylelint2 = _interopRequireDefault(_stylelint);

var _validation = require('./lib/validation');

var _defaults = require('./defaults');

var _defaults2 = _interopRequireDefault(_defaults);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ruleName = 'scale-unlimited/declaration-strict-value';
var utils = _stylelint2.default.utils;

var messages = utils.ruleMessages(ruleName, {
  expected: _validation.expected
});
var reSkipProp = /^(?:@|\$|--).+$/;
var reVar = /^-?(?:@.+|\$.+|var\(--.+\))$/;
var reFunc = /^(?!var\(--).+\(.*\)$/;

var rule = function rule(properties, options) {
  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return function (root, result) {
    // validate stylelint plugin options
    var hasValidOptions = utils.validateOptions(result, ruleName, {
      actual: properties,
      possible: _validation.validProperties
    }, {
      actual: options,
      possible: _validation.validOptions,
      optional: true
    });

    if (!hasValidOptions) return;

    // normalize options
    if (!Array.isArray(properties)) {
      // eslint-disable-next-line no-param-reassign
      properties = [properties];
    }

    var config = _extends({}, _defaults2.default, options);
    var ignoreVariables = config.ignoreVariables,
        ignoreFunctions = config.ignoreFunctions,
        ignoreKeywords = config.ignoreKeywords,
        message = config.message,
        disableFix = config.disableFix,
        autoFixFunc = config.autoFixFunc;

    var autoFixFuncNormalized = (0, _validation.getAutoFixFunc)(autoFixFunc);
    var reKeywords = ignoreKeywords ? {} : null;

    // loop through all properties
    properties.forEach(function (property) {
      var propFilter = property;

      // parse RegExp
      if (propFilter.charAt(0) === '/' && propFilter.slice(-1) === '/') {
        propFilter = new RegExp(propFilter.slice(1, -1));
      }

      // walk through all declarations filtered by configured properties
      root.walkDecls(propFilter, lintDeclStrictValue);

      /**
       * Lint usages of declarations values againts, variables, functions
       * or custum keywords - as configured.
       *
       * @param {Object} node - A Declaration-Node from PostCSS AST-Parser.
       */
      function lintDeclStrictValue(node) {
        var value = node.value,
            prop = node.prop;

        // skip variable declarations

        if (reSkipProp.test(prop)) return;

        // falsify everything by default
        var validVar = false;
        var validFunc = false;
        var validKeyword = false;

        // test variable
        if (ignoreVariables) {
          validVar = reVar.test(value);
        }

        // test function
        if (ignoreFunctions && !validVar) {
          validFunc = reFunc.test(value);
        }

        // test keywords
        if (ignoreKeywords && (!validVar || !validFunc)) {
          var reKeyword = reKeywords[property];

          if (!reKeyword) {
            var ignoreKeyword = (0, _validation.getIgnoredKeywords)(ignoreKeywords, property);

            if (ignoreKeyword) {
              reKeyword = new RegExp('^' + ignoreKeyword.join('|') + '$');
              reKeywords[property] = reKeyword;
            }
          }

          if (reKeyword) {
            validKeyword = reKeyword.test(value);
          }
        }

        // report only if all failed
        if (!validVar && !validFunc && !validKeyword) {
          var types = (0, _validation.getTypes)(config, property);
          var raws = node.raws;
          var start = node.source.start;

          // support auto fixing

          if (context.fix && !disableFix) {
            var fixedValue = autoFixFuncNormalized(node, { validVar: validVar, validFunc: validFunc, validKeyword: validKeyword }, root, config);

            // apply fixed value if returned
            if (fixedValue) {
              // eslint-disable-next-line no-param-reassign
              node.value = fixedValue;
            }
          } else {
            utils.report({
              ruleName: ruleName,
              result: result,
              node: node,
              line: start.line,
              column: start.column + prop.length + raws.between.length,
              message: messages.expected(types, value, prop, message)
            });
          }
        }
      }
    });
  };
};

rule.primaryOptionArray = true;

var declarationStrictValuePlugin = _stylelint2.default.createPlugin(ruleName, rule);

exports.default = declarationStrictValuePlugin;
exports.ruleName = ruleName;
exports.messages = messages;